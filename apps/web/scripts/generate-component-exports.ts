#!/usr/bin/env tsx
/**
 * Component Export Generator
 * Auto-generates barrel exports from component registry
 *
 * Usage:
 *   pnpm generate:components
 *   tsx scripts/generate-component-exports.ts
 */

import * as fs from 'fs';
import * as path from 'path';

interface ComponentRegistryEntry {
  path: string;
  export: string | string[];
  category?: string;
  description?: string;
  aliases?: string[];
  deprecated?: boolean;
  replacement?: string;
}

interface ComponentCategory {
  [componentName: string]: ComponentRegistryEntry;
}

interface ComponentRegistry {
  $schema?: string;
  version: string;
  components: {
    [category: string]: ComponentCategory;
  };
  aliases?: {
    [alias: string]: string;
  };
  overrides?: {
    [componentName: string]: {
      path: string;
      export: string | string[];
    };
  };
}

const REGISTRY_PATH = path.join(process.cwd(), 'src/components/component-registry.json');
const COMPONENTS_DIR = path.join(process.cwd(), 'src/components');

/**
 * Load the component registry
 */
function loadRegistry(): ComponentRegistry {
  try {
    const content = fs.readFileSync(REGISTRY_PATH, 'utf-8');
    return JSON.parse(content);
  } catch (error) {
    console.error('âŒ Failed to load component registry:', error);
    process.exit(1);
  }
}

/**
 * Generate export statement for a component
 */
function generateExportStatement(
  componentName: string,
  entry: ComponentRegistryEntry,
  includeComment: boolean = true
): string {
  const lines: string[] = [];

  if (includeComment && entry.description) {
    lines.push(`/** ${entry.description} */`);
  }

  if (entry.deprecated) {
    lines.push(`/** @deprecated ${entry.replacement ? `Use ${entry.replacement} instead` : 'This component is deprecated'} */`);
  }

  const exportNames = Array.isArray(entry.export) ? entry.export : [entry.export];

  if (exportNames.length === 1 && exportNames[0] === 'default') {
    // Default export - re-export as named
    lines.push(`export { default as ${componentName} } from '${entry.path}';`);
  } else if (exportNames.includes('default')) {
    // Has both default and named exports
    const namedExports = exportNames.filter(e => e !== 'default');
    lines.push(`export { default as ${componentName}, ${namedExports.join(', ')} } from '${entry.path}';`);
  } else {
    // Only named exports
    lines.push(`export { ${exportNames.join(', ')} } from '${entry.path}';`);
  }

  return lines.join('\n');
}

/**
 * Generate barrel export file for a category
 */
function generateCategoryIndex(category: string, components: ComponentCategory): string {
  const lines: string[] = [
    '/**',
    ` * Auto-generated barrel exports for ${category} components`,
    ' * DO NOT EDIT MANUALLY - Generated by scripts/generate-component-exports.ts',
    ` * Generated: ${new Date().toISOString()}`,
    ' */',
    '',
  ];

  // Sort components alphabetically
  const sortedComponents = Object.entries(components).sort(([a], [b]) => a.localeCompare(b));

  for (const [componentName, entry] of sortedComponents) {
    lines.push(generateExportStatement(componentName, entry, true));
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Generate main index file that re-exports all categories
 */
function generateMainIndex(registry: ComponentRegistry): string {
  const lines: string[] = [
    '/**',
    ' * Auto-generated main component exports',
    ' * DO NOT EDIT MANUALLY - Generated by scripts/generate-component-exports.ts',
    ` * Version: ${registry.version}`,
    ` * Generated: ${new Date().toISOString()}`,
    ' */',
    '',
    '// Re-export all components from categories',
  ];

  const categories = Object.keys(registry.components).sort();

  for (const category of categories) {
    lines.push(`export * from './${category}';`);
  }

  // Add utility exports
  lines.push('');
  lines.push('// Component registry utilities');
  lines.push("export * from './component-loader';");
  lines.push("export type * from './registry-types';");

  return lines.join('\n');
}

/**
 * Generate TypeScript declaration file for better IDE support
 */
function generateDeclarationFile(registry: ComponentRegistry): string {
  const lines: string[] = [
    '/**',
    ' * Component Registry Type Declarations',
    ' * Provides type information for all registered components',
    ' */',
    '',
    "import type { ComponentRegistry } from './registry-types';",
    '',
    'declare const registry: ComponentRegistry;',
    '',
    '// Component categories',
  ];

  for (const category of Object.keys(registry.components)) {
    lines.push(`export type ${capitalize(category)}Components = keyof typeof registry.components.${category};`);
  }

  lines.push('');
  lines.push('// All component names');
  lines.push('export type ComponentName = ');

  const allNames: string[] = [];
  for (const components of Object.values(registry.components)) {
    allNames.push(...Object.keys(components));
  }

  lines.push(allNames.map(name => `  | '${name}'`).join('\n'));
  lines.push(';');

  return lines.join('\n');
}

/**
 * Capitalize first letter
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Write file safely with backup
 */
function writeFileSafe(filePath: string, content: string): void {
  const dir = path.dirname(filePath);

  // Ensure directory exists
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  // Backup existing file if it exists and wasn't auto-generated
  if (fs.existsSync(filePath)) {
    const existingContent = fs.readFileSync(filePath, 'utf-8');
    if (!existingContent.includes('DO NOT EDIT MANUALLY')) {
      const backupPath = `${filePath}.backup`;
      fs.writeFileSync(backupPath, existingContent);
      console.log(`   ðŸ“¦ Backed up manual edits to ${path.basename(backupPath)}`);
    }
  }

  fs.writeFileSync(filePath, content, 'utf-8');
}

/**
 * Main execution
 */
function main() {
  console.log('ðŸš€ Generating component barrel exports...\n');

  const registry = loadRegistry();
  const categories = Object.keys(registry.components);

  console.log(`ðŸ“‹ Registry version: ${registry.version}`);
  console.log(`ðŸ“ Found ${categories.length} categories\n`);

  // Generate category index files
  for (const [category, components] of Object.entries(registry.components)) {
    const componentCount = Object.keys(components).length;
    console.log(`ðŸ“¦ Generating ${category}/index.ts (${componentCount} components)`);

    const indexContent = generateCategoryIndex(category, components);
    const indexPath = path.join(COMPONENTS_DIR, category, 'index.ts');

    writeFileSafe(indexPath, indexContent);
  }

  // Generate main index file
  console.log('\nðŸ“¦ Generating main components/index.ts');
  const mainIndexContent = generateMainIndex(registry);
  const mainIndexPath = path.join(COMPONENTS_DIR, 'index.ts');
  writeFileSafe(mainIndexPath, mainIndexContent);

  // Generate type declarations
  console.log('ðŸ“¦ Generating component-names.d.ts');
  const declarationContent = generateDeclarationFile(registry);
  const declarationPath = path.join(COMPONENTS_DIR, 'component-names.d.ts');
  writeFileSafe(declarationPath, declarationContent);

  // Statistics
  const totalComponents = Object.values(registry.components).reduce(
    (sum, cat) => sum + Object.keys(cat).length,
    0
  );

  console.log('\nâœ… Generation complete!\n');
  console.log('ðŸ“Š Statistics:');
  console.log(`   - Categories: ${categories.length}`);
  console.log(`   - Total components: ${totalComponents}`);
  console.log(`   - Aliases: ${Object.keys(registry.aliases || {}).length}`);
  console.log('\nðŸ’¡ You can now import components like:');
  console.log('   import { Button, Card } from "@/components"');
  console.log('   import { Button } from "@/components/ui"');
}

// Run if called directly
if (require.main === module) {
  main();
}

export { main as generateComponentExports };
